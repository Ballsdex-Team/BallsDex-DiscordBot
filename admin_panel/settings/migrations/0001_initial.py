# Generated by Django 5.2.8 on 2025-11-21 10:46

import re
from typing import TYPE_CHECKING, cast

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models

if TYPE_CHECKING:
    from django.apps.registry import Apps
    from django.db.backends.base.schema import BaseDatabaseSchemaEditor

    from ..models import PromptMessage, Settings


def default_settings_forward(apps: "Apps", schema_editor: "BaseDatabaseSchemaEditor"):
    settings = cast(type["Settings"], apps.get_model("settings", "Settings"))
    prompt_message = cast(type["PromptMessage"], apps.get_model("settings", "PromptMessage"))
    instance = settings.objects.create()
    instance.prompts.bulk_create(
        (
            prompt_message(settings=instance, category=1, message="{user} You caught **{ball}**!"),
            prompt_message(settings=instance, category=2, message="{user} Wrong name!"),
            prompt_message(settings=instance, category=3, message="A wild {collectible} appeared!"),
            prompt_message(
                settings=instance, category=4, message="{user} Sorry, this {collectible} was caught already!"
            ),
        )
    )


def default_settings_backwards(apps: "Apps", schema_editor: "BaseDatabaseSchemaEditor"):
    # nothing to be done, model deletion will result on instance deletion anyway
    pass


class Migration(migrations.Migration):
    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Settings",
            fields=[
                ("id", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("bot_token", models.CharField(default="", help_text="Discord bot token", max_length=80)),
                ("prefix", models.CharField(default="b.", help_text="Prefix for all text commands", max_length=10)),
                (
                    "collectible_name",
                    models.TextField(default="countryball", help_text="The singular name of your collectible"),
                ),
                (
                    "plural_collectible_name",
                    models.TextField(default="countryballs", help_text="The plural name of your collectible"),
                ),
                ("bot_name", models.TextField(default="BallsDex", help_text="The name of your bot")),
                (
                    "balls_slash_name",
                    models.TextField(
                        default="balls",
                        help_text='Overrides "/balls" slash command',
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^[-_'\\S]{1,32}$"), message="Invalid slash command name."
                            )
                        ],
                    ),
                ),
                (
                    "favorited_collectible_emoji",
                    models.CharField(default="❤️", help_text="Emoji for the favorited collectibles", max_length=3),
                ),
                (
                    "max_favorites",
                    models.PositiveIntegerField(default=20, help_text="Maximum number of favorites configurable"),
                ),
                (
                    "max_attack_bonus",
                    models.PositiveIntegerField(
                        default=20,
                        help_text="Min/max bonus for attack statistic. A value of 20 means it goes from -20% to 20%",
                    ),
                ),
                (
                    "max_health_bonus",
                    models.PositiveIntegerField(
                        default=20,
                        help_text="Min/max bonus for health statistic. A value of 20 means it goes from -20% to 20%",
                    ),
                ),
                (
                    "show_rarity",
                    models.BooleanField(
                        default=False, help_text="Whether to show the rarity on the card (replaces economy icon)"
                    ),
                ),
                (
                    "catch_button_label",
                    models.CharField(default="Catch me", help_text="Label of the catch button", max_length=80),
                ),
                (
                    "spawn_chance_min",
                    models.PositiveIntegerField(
                        default=40,
                        help_text="Minimum base chance value to spawn a ball. Lower value leads to more spawn.",
                    ),
                ),
                (
                    "spawn_chance_max",
                    models.PositiveIntegerField(
                        default=55,
                        help_text="Maximum base chance value to spawn a ball. Lower value leads to more spawn. "
                        "A wide range between min and max leads to a broader difference in spawn times.",
                    ),
                ),
                (
                    "spawn_manager",
                    models.TextField(
                        default="ballsdex.packages.countryballs.spawn.SpawnManager",
                        help_text="Python path to a class that will handle spawn logic.",
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^[a-zA-Z_][\\\\.a-zA-Z0-9_]+$"), message="This is not a valid Python path."
                            )
                        ],
                    ),
                ),
                (
                    "about_description",
                    models.TextField(
                        default="Collect countryballs on Discord, exchange them and battle with friends!",
                        help_text="A small text bot shown in the /about command.",
                    ),
                ),
                (
                    "repository",
                    models.URLField(
                        default="https://github.com/Ballsdex-Team/BallsDex-DiscordBot",
                        help_text="URL to the repository with the source code.",
                    ),
                ),
                (
                    "discord_invite",
                    models.URLField(
                        default="",
                        help_text="Invite to a Discord server that you own. Shown in /about and to blacklisted users.",
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^https?://(discord.gg|discord(app)?.com/invite)/[a-zA-Z0-9]+$"),
                                message="This is not a valid Discord invite.",
                            )
                        ],
                    ),
                ),
                ("terms_of_service", models.URLField(default="", help_text="Link to your terms of service.")),
                ("privacy_policy", models.URLField(default="", help_text="Link to your privacy policy.")),
                (
                    "admin_channel_ids",
                    models.TextField(
                        blank=True,
                        default="",
                        help_text="Semicolon-delimited list of channel IDs where admin commands can be used. "
                        "Ignored for owners. If empty, then admin commands can be used everywhere.",
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^(\\d{17,21}(;\\d{17,21})*)?$"),
                                message="The IDs must be semicolon-separated",
                            )
                        ],
                    ),
                ),
                (
                    "webhook_logging",
                    models.URLField(
                        blank=True,
                        default=None,
                        help_text="An optional Discord Webhook where admin events will be logged.",
                        null=True,
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^https://discord.com/api/webhooks/[0-9]{17,22}/[a-zA-Z0-9-_]{68}$"),
                                message="Only Discord webhooks are supported.",
                            )
                        ],
                    ),
                ),
                (
                    "team_owners",
                    models.BooleanField(
                        default=False,
                        help_text="Whether to consider Discord Developer Team members (regardless of their roles) "
                        "as owner of the bot.",
                    ),
                ),
                (
                    "coowners",
                    models.TextField(
                        blank=True,
                        default=None,
                        help_text="A list of user IDs that must be considered bot owners. "
                        "This will give them full privilege.",
                        null=True,
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^(\\d{17,21}(;\\d{17,21})*)?$"),
                                message="The IDs must be semicolon-separated",
                            )
                        ],
                    ),
                ),
                (
                    "prometheus_enabled",
                    models.BooleanField(default=False, help_text="Enable the Prometheus metrics collection"),
                ),
                (
                    "prometheus_host",
                    models.GenericIPAddressField(default="0.0.0.0", help_text="IP to bind for Prometheus server"),
                ),
                (
                    "prometheus_port",
                    models.PositiveIntegerField(default=15260, help_text="Port to bind for Prometheus server"),
                ),
                (
                    "client_id",
                    models.PositiveBigIntegerField(
                        blank=True, default=None, help_text="OAuth2 Discord application ID", null=True
                    ),
                ),
                (
                    "client_secret",
                    models.TextField(
                        blank=True, default=None, help_text="OAuth2 Discord application secret", null=True
                    ),
                ),
                (
                    "sentry_dsn",
                    models.URLField(
                        blank=True, default=None, help_text="Sentry DSN URL for error reporting", null=True
                    ),
                ),
                (
                    "sentry_env",
                    models.CharField(
                        default="production",
                        help_text="Sentry environment key",
                        max_length=64,
                        validators=[
                            django.core.validators.RegexValidator(
                                re.compile("^(?!None$)[^\\s/]{,64}$"),
                                message="Sentry environment key cannot contain spaces, newlines or forward slashes, "
                                'can\'t be the string "None", or exceed 64 characters.',
                            )
                        ],
                    ),
                ),
            ],
            options={
                "verbose_name_plural": "Settings",
                "constraints": [
                    models.CheckConstraint(
                        condition=models.Q(
                            models.Q(
                                models.Q(("client_id", None), ("client_id", 0), _connector="OR"),
                                models.Q(("client_secret", None), ("client_secret", ""), _connector="OR"),
                            ),
                            models.Q(("client_id__isnull", False), ("client_secret__isnull", False)),
                            _connector="OR",
                        ),
                        name="oauth_params_null_together",
                        violation_error_message="client_id and client_secret must both be set or null, "
                        "you cannot set only one.",
                    ),
                    models.CheckConstraint(
                        condition=models.Q(("spawn_chance_min__lte", models.F("spawn_chance_max"))),
                        name="spawn_chance_min_lt_max",
                        violation_error_message="Minimum spawn chance value must be lower or equal to maximum chance.",
                    ),
                ],
            },
        ),
        migrations.CreateModel(
            name="PromptMessage",
            fields=[
                ("id", models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name="ID")),
                ("message", models.TextField(help_text="The message to send")),
                (
                    "category",
                    models.PositiveSmallIntegerField(
                        choices=[(1, "Catch"), (2, "Wrong"), (3, "Spawn"), (4, "Slow")], help_text="Message category"
                    ),
                ),
                (
                    "settings",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE, related_name="prompts", to="settings.settings"
                    ),
                ),
            ],
        ),
        migrations.RunPython(default_settings_forward, default_settings_backwards),
    ]
